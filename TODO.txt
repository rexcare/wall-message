
TODO:

X get Flask container working
X figure out where to put frontend files
X serve Vue SPA index with Flask
X serve static files with Flask
X add node_modules to docker image
X figure out dev mode and prod mode for backend and frontend
X get docker dev mode process to update files on save
X cleanup root directory configs, put in own directory
X separate server and client files
X convert container build and run to docker-compose (for dev and prod modes)
X get scss compiling correctly with webpack
X add axios
X add service architecture
X add http service
X add backend API call to Vue client
X add mysql
X add reddis cache
X add utils directory with helper modules
X add application server config
X add mysql database driver with basic CRUD interface
X add database driver base class which enforces an interace on all subclasses
X add dataobject layer
X add base_data_object
X add example_data_object
X build abstract base cache driver class and redis driver class
X test redis driver
X incorporate caching into base data object class
X test data object caching with ExampleDataObject
X add docstrings to caching layer
X add docstrings to dataobject layer
X finish implementing MySqlDriver table methods
X architect backend endpoint routing
X change 'model' layer to be named 'service'
X implement a message board for fullstack example of framework
- do cleanup for final version of project-seed

TODO for application server config:
X map-in items:
	DATABASE_HOST
	DATABASE_USER
	DATABASE_PASSWORD
	DATABASE_NAME
- consider multiple config files for different parts of the application

TODO for datastore driver layer:
X stub mysql_driver methods
X create test script for mysql_driver
X implement mysql_driver class
X test mysql_driver class

TODO for dataobject layer:
X architect dataobject layer (base_dataobject->child_dataobjects)
X stub methods
X create test script
X implement class
X test class

TODO for cache driver layer:
X create and stub BaseCacheDriver
X create and stub RedisDriver
X test RedisDriver with test script

TODO for incorporating caching into base data object class:
X think about where to apply caching:
	X load
	X save
	X delete
X stub private caching methods in BaseDataObject
X incorporate caching in CRUD methods
X test new caching with testExampleDataObject test script
X update testExampleDataObject script to specifically test caching
X test with testExampleDataObject script again

TODO for message board example:
X create MySQL table 'wall_message'
X create and implement WallMessageDataObject class
X create and implement WallMessageModel class
X create and implement WallMessageWebAPI class
X create and implement web client view, components, state, backend calls
X add wall message edit feature
X add caching

TODO for final cleanup
X create script for wall_message table creation
X delete test class ExampleDataObject
X delete test script for testing ExampleDataObject
- create small test framework for running test scripts
- alter test scripts to be able to be run with minimal setup
- delete NOTES file
X delete test backend API endpoints
X cleanup everything else that doesn't focus on the WallMessage feature
- update README with information about backend framework




